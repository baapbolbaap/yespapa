1. 

import networkx as nx

G = nx.Graph()
G.add_nodes_from([1, 2, 3, 4])
G.add_edges_from([(1, 2), (1, 3), (2, 3), (3, 4)])

DG = nx.DiGraph()
DG.add_nodes_from([1, 2, 3, 4])
DG.add_edges_from([(1, 2), (2, 1), (1, 3), (3, 2), (3, 4)])

num_nodes = G.number_of_nodes()
print("Number of nodes:", num_nodes)

num_edges = G.number_of_edges()
print("Number of edges:", num_edges)

degree_node_1 = G.degree(1)
print("Degree of node 1:", degree_node_1)

degrees = dict(G.degree())
lowest_degree_node = min(degrees, key=degrees.get)
lowest_degree_value = degrees[lowest_degree_node]
print("Node with lowest degree:", lowest_degree_node, "with degree", lowest_degree_value)

adj_list = dict(G.adjacency())
print("Adjacency list:", adj_list)

adj_list = {node: list(neighbors) for node, neighbors in G.adjacency()}
print("Adjacency List:", adj_list)
adj_matrix = nx.to_numpy_array(G)
print("Adjacency matrix:\n", adj_matrix)



2. Degree , centrality

import networkx as nx 
G = nx.DiGraph() 
G.add_edges_from([(1,2), (2,1), (2,3), (3,1)]) 
 
print("Density:", nx.density(G)) 
# Degree of nodes 
print("\nDegrees:") 
for n, d in G.degree():
    print(n, ":", d) 

print("\nReciprocity:", nx.reciprocity(G)) 
print("Transitivity:", nx.transitivity(G))

deg_cent = nx.degree_centrality(G)
centralization = max(deg_cent.values()) - sum(deg_cent.values())/len(deg_cent) 
print("Centralization:", centralization) 
print("\nClustering Coefficients:") 
print(nx.clustering(G.to_undirected())) 


3. two-mode

import networkx as nx 
import matplotlib.pyplot as plt 
from networkx.algorithms import community 
from networkx.algorithms import bipartite 
B = nx.Graph() 
actors = ["A1", "A2", "A3", "A4", "A5"] 
events = ["E1", "E2", "E3"] 
B.add_nodes_from(actors, bipartite=0) 
B.add_nodes_from(events, bipartite=1) 
edges = [ 
("A1", "E1"), ("A2", "E1"), ("A3", "E1"), 
("A1", "E2"), ("A2", "E2"), ("A4", "E3"), ("A5", "E3") 
] 
B.add_edges_from(edges) 
actor_projection = bipartite.projected_graph(B, actors) 
# Step 3: Find factions (communities) in actor projection 
# Here using Girvanâ€“Newman as an example 
comp = community.girvan_newman(actor_projection) 
# Extract first level partition 
factions = tuple(sorted(c) for c in next(comp)) 
print("Factions (Actor groups):", factions) 
 
pos = nx.spring_layout(actor_projection, seed=42) 
colors = ["lightblue", "lightgreen", "lightpink", "orange"] 
plt.figure(figsize=(8,6)) 
for i, group in enumerate(factions):
    nx.draw_networkx_nodes(actor_projection, pos, nodelist=group,node_color=colors[i % len(colors)], label=f"Faction {i+1}")
    nx.draw_networkx_edges(actor_projection, pos, alpha=0.5)
    nx.draw_networkx_labels(actor_projection, pos) 
plt.title("Two-Mode Faction Analysis (projected onto Actors)") 
plt.legend() 
plt.show() 

4. equvalence

import networkx as nx
import matplotlib.pyplot as plt

def structural_equivalence(graph):
    return [(u, v) for u in graph for v in graph if u < v and set(graph[u]) == set(graph[v])]

def automorphic_equivalence(graph, node1, node2):
    return nx.is_isomorphic(graph, nx.relabel_nodes(graph, {node1: node2, node2: node1}))

def regular_equivalence(graph, node1, node2):
    return graph.degree(node1) == graph.degree(node2)

graph_structural = nx.Graph([
    ("A","K"),("A","L"),
    ("B","K"),("B","L"),
    ("C","M"),("D","M")
])

graph_automorphic = nx.Graph([
    ("P","Q"),("Q","R"),("R","P")
])

graph_regular = nx.Graph([
    ("Teacher1","Student1"),
    ("Teacher1","Student2"),
    ("Teacher2","Student3"),
    ("Teacher2","Student4")
])

print("Structural Equivalence:", structural_equivalence(graph_structural))
print("Automorphic Equivalence (P,Q):", automorphic_equivalence(graph_automorphic,"P","Q"))
print("Regular Equivalence (Teacher1,Teacher2):", regular_equivalence(graph_regular,"Teacher1","Teacher2"))

fig, ax = plt.subplots(1, 3, figsize=(10, 3))
graphs = [
    (graph_structural, "Structural"),
    (graph_automorphic, "Automorphic"),
    (graph_regular, "Regular")
]

for i, (g, title) in enumerate(graphs):
    pos = nx.spring_layout(g, seed=5)
    nx.draw(g, pos, with_labels=True, node_size=700, ax=ax[i])
    ax[i].set_title(title)

plt.tight_layout()
plt.show()


5. Ego

import networkx as nx
import matplotlib.pyplot as plt

G = nx.Graph()

edges = [("A","B"),("A","C"),("B","C"),
         ("C","D"),("D","E"),("E","F"),
         ("C","F")]

G.add_edges_from(edges)

plt.figure(1)
nx.draw(G, with_labels=True, node_size=1200)
plt.title("Sociocentric Network")


ego = "C"   # select ego
ego_graph = nx.ego_graph(G, ego)

plt.figure(2)
nx.draw(ego_graph, with_labels=True, node_color="lightgreen", node_size=1200)
plt.title("Egocentric Network (Ego = C)")

plt.show()

